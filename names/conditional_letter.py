"""Description:
Script to generate an array of 3d letters, each as a combination of two input letters.
3d matrix is generated by taking the outer product of the 2d patterns of the letters.
Then the matrix is rendered in openSCAD using the pythonopenscad library.
The 3d array is displayed using the viewscad library.
Finally, the model is exported to .stl format for 3d-printing.
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import CubicSpline
import letter_to_pixel as ltp

import pythonopenscad as posc
from euclid3 import Point3
import sys

# |%%--%%| <WXj8UyVFXG|6bIykLUAam>


def get_conditional_letter(l1, l2):
    """Generate 3D letter pattern by combining two 2D letter patterns."""
    try:
        a = np.array(ltp.get_letter_pattern(l1))
        b = np.array(ltp.get_letter_pattern(l2))
        return a[:, :, np.newaxis] @ b[:, np.newaxis, :]
    except Exception as e:
        print(f"Error generating pattern for letters {l1}, {l2}: {e}")
        return None


# |%%--%%| <6bIykLUAam|L9ZQ1xJ5DO>


def plot_cond_letter(c, title="3D Letter Combination"):
    """Plot 3D voxel representation of letter combination."""
    if c is None:
        print("Cannot plot None array")
        return

    fig = plt.figure(figsize=(10, 8))
    ax = fig.add_subplot(111, projection="3d")
    ax.voxels(c)
    ax.set_title(title)
    plt.show()


# |%%--%%| <L9ZQ1xJ5DO|1JB5Kp5fka>


def spline_interp(c, smoothing_factor=0.1):
    """Apply Bezier-like smoothing to 3D points using cubic splines."""
    if c is None:
        return None

    # Extract coordinates of non-zero voxels
    coords = np.argwhere(c > 0)
    if len(coords) == 0:
        return c

    # Create smoothed version by interpolating between points
    smoothed = np.zeros_like(c, dtype=float)

    # Group points by layers and apply spline interpolation
    for layer in range(c.shape[2]):
        layer_coords = coords[coords[:, 2] == layer]
        if len(layer_coords) > 3:  # Need at least 4 points for cubic spline
            try:
                # Sort by x-coordinate for interpolation
                layer_coords = layer_coords[np.argsort(layer_coords[:, 0])]
                x = layer_coords[:, 0].astype(float)
                y = layer_coords[:, 1].astype(float)

                # Create cubic spline
                cs = CubicSpline(x, y, bc_type="natural")

                # Interpolate additional points
                x_new = np.linspace(
                    x.min(), x.max(), int(len(x) * (1 + smoothing_factor))
                )
                y_new = cs(x_new)

                # Add interpolated points to smoothed array
                for xi, yi in zip(x_new, y_new):
                    xi_int, yi_int = int(round(xi)), int(round(yi))
                    if 0 <= xi_int < c.shape[0] and 0 <= yi_int < c.shape[1]:
                        smoothed[xi_int, yi_int, layer] = 1.0
            except:
                # Fallback to original points if spline fails
                for coord in layer_coords:
                    smoothed[coord[0], coord[1], coord[2]] = 1.0
        else:
            # Not enough points for spline, use original
            for coord in layer_coords:
                smoothed[coord[0], coord[1], coord[2]] = 1.0

    return smoothed


def array_to_vertices(c):
    """Convert 3D array to OpenSCAD vertices."""
    if c is None:
        return None

    verts = []
    for i in range(c.shape[0]):
        for j in range(c.shape[1]):
            for k in range(c.shape[2]):
                if c[i, j, k] > 0:
                    verts.append(Point3(i, j, k))

    if not verts:
        return None

    cubes = [posc.cube(1).translate(v) for v in verts]
    result = cubes[0]
    for cube in cubes[1:]:
        result = result + cube
    return result


def generate_scad_code(s1, s2):
    """Generate OpenSCAD code for 3D printing with smooth Bezier-like curves."""
    scad_code = "// Generated 3D Letter Combinations\n"
    scad_code += f"// {s1} + {s2}\n\n"
    scad_code += "$fn=20;\n"

    scad_code += "// Base Plate\n"
    scad_code += f"translate([-3, -4, 0]) cube([{10 * len(s1)}, 8, 2]);\n\n"

    # Process each letter pair
    for i in range(len(s1)):
        c = get_conditional_letter(s1[i], s2[i])
        if c is None:
            continue

        # Apply smoothing
        c_smooth = spline_interp(c)
        if c_smooth is None:
            continue

        # Add letter comment
        scad_code += f"// Letter {s1[i]} + {s2[i]}\n"

        scad_code += (
            f"translate([0,0,9]) translate([{i * 10}, 0, 0]) rotate([45,90,0]) {{\n"
        )
        scad_code += "  union() {\n"

        # Create continuous smooth geometry using metaballs/implicit surfaces
        # This creates overlapping spheres that will merge into smooth surfaces
        for x in range(c_smooth.shape[0]):
            for y in range(c_smooth.shape[1]):
                for z in range(c_smooth.shape[2]):
                    if c_smooth[x, y, z] > 0:
                        # Use intersection of sphere and cube for smooth rounded cubes
                        scad_code += f"    translate([{x}, {y}, {z}]) {{\n"
                        # scad_code += "      intersection() {\n"
                        # scad_code += "        sphere(r=1.0);\n"
                        scad_code += "        cube([2,2,2], center=true);\n"
                        # scad_code += "      }\n"
                        scad_code += "    }\n"

        scad_code += "  }\n"
        scad_code += "}\n\n"

    return scad_code


def main():
    """Main function to generate and display conditional letters.
    run like: python conditional_letter.py name1 name2"""

    s1 = str(sys.argv[2]).upper()
    s2 = str(sys.argv[1]).upper()

    # Ensure strings are same length
    # min_len = min(len(s1), len(s2))
    # s1, s2 = s1[:min_len], s2[:min_len]

    all_objects = []

    # Process each letter pair
    for i in range(len(s1)):
        print(f"Processing letter pair: {s1[i]} + {s2[i]}")

        # Generate conditional letter
        c = get_conditional_letter(s1[i], s2[i])
        if c is None:
            continue

        # Apply Bezier-like smoothing
        c_smooth = spline_interp(c, 1)

        # Convert to 3D object
        obj = array_to_vertices(c_smooth)
        if obj is not None:
            # Position letters side by side
            obj = obj.translate(Point3(i * 10, 0, 0))
            obj = obj.rotate((0, 90, 0))
            all_objects.append(obj)

            # Optional: plot individual letters
            # plot_cond_letter(c_smooth, f"Letter {s1[i]} + {s2[i]}")

    # Combine all objects and display
    if all_objects:
        # combined_object = posc.union(*all_objects)
        combined_object = all_objects[0]
        for obj in all_objects[1:]:
            combined_object = combined_object + obj

        # Generate OpenSCAD code manually for 3D printing
        print("Generating OpenSCAD code for 3D printing...")
        scad_code = generate_scad_code(s1, s2)

        filename = f"out/{s1}_{s2}_conditional_letters.scad"
        with open(filename, "w") as f:
            f.write(scad_code)
        print(f"OpenSCAD model exported to {filename}")
        print(
            "You can now open this file in OpenSCAD and export to STL for 3D printing"
        )

        # Also show matplotlib visualization
        # print("Displaying individual letters with matplotlib...")
        # for i in range(len(s1)):
        #     c = get_conditional_letter(s1[i], s2[i])
        #     if c is not None:
        #         c_smooth = spline_interp(c)
        #         plot_cond_letter(c_smooth, f"Letter {s1[i]} + {s2[i]}")
    else:
        print("No valid letter combinations generated")


if __name__ == "__main__":
    main()
